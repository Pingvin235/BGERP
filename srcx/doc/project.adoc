= Development
:toc:
:toclevels: 4

BGERP is quite a large and complex project. It was created by a team consisting of ordinary humans, who may be imperfect and make
mistakes but try to learn continuously. This is a trial and error process, fortunately or not.

This article provides some recommendations collected during the learning process - these are accompanied by a very small amount of <<samples, code>>
for exactly the same reason. Said that, you have to follow those recommendations using *The Boy Scout Rule*.

IMPORTANT: Always leave the campground cleaner than you found it.

While changing a block of code, it is important to try to decrease the usage of outdated approaches, methods and classes.
Write a new code and keep it compliant with the latest recommendations, but at the same time try to get neighboring/adjacent code improved.
During <<workflow, changes>> testing, code improvements will be tested as well.
All in all, gradually, we will improve overall code quality.
We plan to introduce a set of formal code quality metrics: number of compiler warnings, format checks, etc.


[[lang]]
== Languages
The project currently undergoes a migration process from Russian language to an international one (English).
All the software documentation, including this article, and all log messages will be converted to English.
Information shown to the end-user via interface has to be <<l10n, localized>>.

[[project]]
== Project
=== Development environment
The program can be developed on any Java-supported platform:
[square]
* Windows - currently used by the maintainer;
* Linux;
* MacOS.

Minimal required set of software:
[square]
* <<kernel/install.adoc#java, OpenJDK>>;
* <<kernel/install.adoc#mysql, MySQL>>;
* <<eclipse, IDE Eclipse>>.

[[env-console]]
==== Bash for Windows
NOTE: Skip this chapter when using *NIX OS.

Console link:https://git-scm.com/download/win[client] for version control system <<workflow, GIT>>.

System of <<build, build and publish>> is written on Bash scripts and uses GNU utilities, you can use the following when using Windows:
[square]
* link:https://www.windowscentral.com/install-windows-subsystem-linux-windows-10[WSL] - embedded in Windows virtual Linux machine, tested/approved;
* link:https://www.omgubuntu.co.uk/how-to-install-wsl2-on-windows-10[WSL 2] - the new version of it, not tested yet;
* link:https://www.cygwin.com/[Cygwin] - Windows ports of GNU utils, not tested.

The best console emulator on Windows with embedded FAR Manager - link:https://conemu.github.io/[ConEmu].

=== Format
IDE or editor must be configured for displaying whitespace symbols.

image::_res/ide_format.png[width='600px']

The projects mostly follow recommended formatting rules for each of programming languages they use.
Intention:
[square]
* 4 whitespaces - Java;
* 2 whitespaces - SQL <<db, scripts>>;
* tabs - all the rest.

However because of historical reasons many files have been formatted in a wrong way, and have to be carefully fixed.
Screenshot above shows an example of a Java file still using tabs.

When working on fixing a file format, it is important to use the following rules:
[arabic]
. All new files should be formatted correctly.
. Avoid using both indent symbols (tabs and spaces) inside a single file! Such file becomes unreadable in certain editors. If you notice a file/case like this,
make sure to change all indent symbols in the file to the required format.
. Be cautious when combining file formatting with making <<workflow, changes>> - this can significantly complicate analysis down the road.


[[format-java]]
==== Java
Jave code formatting should be *Java Conventions*-compliant, with the following additional changes (Eclipse formatter settings shown below)

Use settings in  *Windows - Preferences - Java - Code style - Formatter*.
Open a standard formatter and save it under a different name after changing the following parameters:
[square]
* *Indentation - Tab policy* - *Spaces only*
* *Indentation* - *Tab size* - *4*
* *Line Wrapping* - *Maximum line width*  - *150*

*Window - Preferences - Java - Code style - Organize Imports* - put 99 and 1 in the respective fields.

Example/resulting Eclipse formatter file: link:../../.vscode/formatter.xml[formatter.xml]


[[eclipse]]
=== Eclipse
Currently one of the most handy platforms.
Download *Eclipse for Java EE Developers*, as this build already includes GIT client as well as JSP and XML editors.
Install the following plugins:
[square]
* *Buildship Gradle* - <<build, Gradle>> support;
* *AsciiDoctor* -  <<documentation, documentation>> editor;
* *MoreUnit* - convenient plugin to work with <<unit-test, unit-tests>>.

Right-click on the project and invoke *Refresh Gradle Project* menu item.
Also use it every time you change any of the project's libraries.

*Window - Preferences - General - Editors - Text Editors* - set a *Show whitespace characters* checkbox

*Window - Preferences - Team - Git - History* remove  *Relative history* checkbox

Import <<format-java, Java formatter>> via *Window - Preferences - Java - Codestyle - Formatter*.


=== VS Code
A bit faster than Eclipse, has better JavaScript and Gradle support.

Drawbacks:
[square]
* JSP support is nearly absent;
* external GIT client is required.

Visit link:../../.vscode/readme.txt[open] and navigate to `.vscode` catalog in project's root in order to get some configuration examples.
Jave formatter and space symbols indicators have been already enabled there.


[[ide-run]]
=== Running in IDE
Configuration:
[square]
* Main class: ru.bgerp.Server
* Program arguments: start
* VM arguments: -Dbgerp.setup.data=bgerp_test
* Classpath: click on *User entries - Advanced - Add folders* and add project's current folder.

Copy `bgerp.properties` to `bgerp_test.propertes`, replace *GENERATED_PASSWORD* with some random value, possibly using `pwgen` or similar utility.

==== Database
MySQL server may be running on any supported platform, check <<kernel/install.adoc#mysql, configuration>> of it.

For database creation use the following files sequentially:
[square]
* `db_create.sql`, `db_init.sql` from link:https://bgerp.org/download/3.0/bgerp.zip[bgerp.zip] - initial structure;
* `bgerp.sql` from link:https://demo.bgerp.org/bgerp.sql[bgerp.sql] - data after running of <<integration-test, integration test>>.

Replace *GENERATED_PASSWORD* in `db_create.sql` with the value from `bgerp_test.properties` but *surrounded by commas*.

Execute the following mysql commands:
[source, bash]
----
mysql --default-character-set=utf8 -uroot -p < db_create.sql
mysql --default-character-set=utf8 -ubgerp -p < db_init.sql
mysql --default-character-set=utf8 -ubgerp -p bgerp < bgerp.sql
----

For <<db, DB update>> on each start in `.properties` must be set <<kernel/setup.adoc#config-on-start, option>>:
[source]
----
runOnStart+=,ru.bgcrm.util.distr.DevDbUpdater
----

[[log4j]]
==== Logging
By default,  a running in IDE application uses <<kernel/extension.adoc#log4j, logging configuration>> from `src/log4j.properties`.
In order to adjust it, copy the file to the project root (will not be handled by GIT) and make required changes.

[[structure]]
=== Files
Project's folder listing along with decription.
[square]
* *bin* - IDE-compiled Java classes;
* *build* - files related to <build, build>>;
* *docpattern* - <<plugin/document/index.adoc#, Document>> plugin templates ;
* *dyn* - <<kernel/extension.adoc#dyn, dynamic code>>, with examples;
* *dyn.ext* - this folder can be used to mount dynamic classes on <<devm, developer's system>>;
* *filestorage* - file storage when launched from IDE;
* *lib* - Java libraries, which are not linked via <<java-lib, Gradle>>;
* *plugin* - <<plugin, plugin>> declarations;
* *src* - Java source code;
* *srcx* - <<documentation, documentation>>, <<unit-test, unit-tests>>, <<integration-test, integration tests>>, build utilities sources;
* *webapps* -  <<js-lib, Web application>> root;
* *work* - folder created by Tomcat for JSP file compilation.


==== Библиотеки
[[java-lib]]
===== Java
При link:../../build/bgerp/files/erp.sh[запуске] программы подключаются JAR файлы из следующих каталогов:
[square]
* *lib/app* - непосредственно <<build-erp, классы приложения>>;
* *lib/ext* - сторонние библиотеки, необходимые для работы;
* *lib/custom* - дополнительные библиотеки для <<kernel/extension.adoc#dyn, динамического кода>> и JEXL скриптов.

Сторонние библиотеки поставляются в отдельном <<build-update, пакете обновления>>.
Артефакты и версии указываются в файле link:../../build.gradle[build.gradle] для конфигурации *bgerp*.

IMPORTANT: Для данной конфигурации не используются транзитивные зависимости, все необходимые версии библиотек должны быть явно указаны.
Рекомендуемый подход - последовательное добавление минимального набора библиотек до получение работоспособного приложения.
Таким образом уменьшается размер пакета и упрощается сопровождение.

Для IDE Eclipse для ускорения изначальной инициализации проекта по-умолчанию отключена загрузка исходных кодов и документации.
[snippet, from="ec", to="}"]
link:../../build.gradle#L18-L24[build.gradle]

[[js-lib]]
===== JS
JS библиотеки располагаются в следующих каталогах:
[square]
* `webapps/js` - располагаются JS файлы самого приложения: ядра и <<plugin, плагинов>>;
* `webapps/lib` - сторонние библиотеки.

Для упрощения отладки используются не минифицированные версии библиотек.

Некоторые сторонние библиотеки пропатчены, все изменения сопровождены комментариями, пример:
[snippet, from="con", to=");", remove-leading="		"]
link:../../webapps/lib/jquery-ui-1.12.1/jquery-ui.js#L8923-L8930[webapps/lib/jquery-ui-1.12.1/jquery-ui.js]

[[devm]]
=== Методика разработки для клиента
BGERP запускается в IDE, с подключением к удалённой базе и биллингу (при необходимости).
По окончании разработки удалённая база клиента наполнена актуальной конфигурацией и необходимо только обновить сам продукт.
[square]
* Подключаться к клиенту по SSH, пробрасывая соединение к БД и при необходимости к биллингу.
Пример: *ssh user@X.X.X.X -L3307:127.0.0.1:3306 -L8081:Y.Y.Y.Y:8080*
* Создать свой *bgerp_customer.properties* файл, в нём можно прописывать параметры доступа и конфигурацию. Он не сохранится в GIT.
В нём же можно переопределить URL для подключения к биллингу на locahost.
* Переопределить порт для BGERP, тогда можно будет сохранять в браузере пароли под конкретного клиента.
* Создать конфигурацию запуска в IDE с данным properties.
* Можно поправить *.gitignore* для сохранения custom файлов клиента, если работа происходит в форке.

[[workflow]]
== GIT Workflow
В таблице описаны GIT ветки.
Для работы с ними используется link:https://docs.google.com/document/d/15NptRsx1qrdiWEew23EFz6gbxD6S12VQpnBQ6X9NbiQ/edit?usp=sharing[стандартный GIT Workflow],
сходный, например, с ядром Linux.
Основная идея - мерджи производятся только "вниз": с основной ветки на вторичные для получения актуального состояния.
На основную ветку всё переносится посредством патчей, поэтому она имеет линейную структуру.
Вторичные ветки впоследствии могут быть удалены, поскольку вся агрегированная информация из них содержится в основной.

[cols="a,a,a,a", options="header"]
|===
|Ветка
|Базируется на
|Назначение
|<<gitlab-ci, CI>>

|*master*
|
|Стабильная версия программы.
|<<test-integration>>, <<publish-source>>

|*p<ID процесса>-short-description*
|master
|Изменение программы и документации.
|<<test-unit-and-doc>>

|*p11862-documentation*
|master
|Корректировки документации. <<longlife-branch, Долгоживущая ветка>>, периодически переносится на master.
|<<publish-doc>>

|*documentation-change-request*
|p11862-documentation
|Предложения по корректировке документации, могут быть смерджены обратно на p11862-documentation.
|<<test-unit-and-doc>>
|===

Основная ветка проекта - *master*, с неё собираются <<build, сборки>>.
[square]
* Каждое *изменение* должно базироваться на процессе в BGERP BiTel, в котором происходит весь обмен информацией по нему.
* *Идентификатор изменения* - строка *p<ID процесса>*, например *p13455*
* Для каждого изменения создаётся отдельная ветка GIT на базе основной, название начинающееся с идентификатора изменения, разделители - дефисы.
Например: *p11788-link-filter-title*
* В процессе разработки в ветке допускается любая стратегия коммитов: промежуточные коммиты, ответвления, откаты коммитов.
Рекомендуется пушить промежуточные состояния, используя GIT репозитарий как резервную копию.
* На ветку изменения могут быть периодически смерджена основная ветка для синхронизации с актуальным состоянием и *обязательно перед переносом*.
* Необходимые правки <<documentation, документации>> производятся одновременно с модификацией исходного кода.
* Пакет тестового обновления для клиента, равно как и документацию, можно <<build-update, собирать и опубликовать>> из ветки.
* Ветка должна добавлять файл *build/change.<ID процесса>.txt*, при его отсутствии он создаётся автоматически при <<build-update, сборке изменения>>.
В файле на разных строках должны быть описаны новые функции, исправления и прочие изменения.
Формат идентичен с *changes.txt*, в который информация переносится автоматически при публикации <<build-erp, обновления>>.
* По завершению разработки и тестирования у клиента необходимо запросить *перенос* ветки с изменением на основную ветку,
для этого процесс BGERP перевести в статус *Приёмка*.
* После проверки процесс закрывается, а изменение переносится в виде единственного коммита,
с комментарием начинающимся с идентификатора изменения в основную ветку.
* Ветка разработки впоследствии может быть удалена. Автор изменения может быть установлен по идентификатору в комментарии.

[IMPORTANT]
====
Невозможно одновременно тестировать несколько изменений параллельно на одной системе и пользоваться ими.
Каждое изменение будет перетирать другое при установке обновления.
В крайнем случае допустимо создание сборочных веток, на которые смердживаются несколько веток изменений.
====

=== Настройка GIT
Пример настройки в файле `$USER_HOME\.gitconfig`:
[source]
----
[user]
	email = shamil@company.com
	name = Shamil Vakhitov
[credential]
	helper = store
[core]
	autocrlf = false
	fileMode = false
[pull]
	rebase = true
----

NOTE:

=== Команды GIT
Почистить все ссылки на несуществующие более удалённые ветки:
[source]
----
git remote prune origin
----

Получение последних обновлений основной ветки не будучи в ней:
[source]
----
git fetch origin master:master
----

[[accept]]
=== Приёмка и перенос
При принятии изменения производится сравнение ветки с основной.
Поэтому перед передачей изменения необходимо смерджить на ветку актуальное состояние основной.

image::_res/branch_compare.png[]

[[change-file]]
Также необходимо создать и заполнить файл с описанием изменений.
Для этого может быть использована <<build, команда>>:
[bash]
----
bash -c "./gradlew touchChanges"
----

GIT команды для переноса изменений из ветки *pXXXXX-short-change-description* в основную:
[source, bash]
----
git checkout pXXXXX-short-change-description && git pull
git commit --allow-empty -m "MERGED" && git push
git checkout master && git pull
git merge --squash pXXXXX-short-change-description
----

Commit with current GIT user.
[source, bash]
----
git commit -am "pXXXXX Some change description."
----

Or for preserving the author in GitHub. Mapping internal to external mails is available in file `.gitlab-ci-publish-author.sh`
[source, bash]
----
git commit -am "pXXXXX Some change description." --author="Developer Name <internal@gitlab.email>"
----

And final push.
[source, bash]
----
git push
----

Периодически с основной ветки <<build-erp, публикуется обновление>>.

[[longlife-branch]]
=== Долгоживущие ветки
В долгоживущих ветках производятся изменения *не влияющие на функциональность продукта*.
Как-то: корректировка локализации, документации, форматирование кода, тесты.
Процесс изменения при этом не закрывается, а <<accept, перенос>> производится многократно по мере готовности очередной порции изменений.

[[documentation]]
==== Documentation
A particular case of long-life branch is documentation.
The source AsciiDoctor and resource files are placed in `srcx/doc` directory.
Publication of the product manual <<publish-doc, runs>> automcatically from <<workflow, branch>> *p11862-documentation*.

Documentation might be <<build-doc, built>> also locally from any branch and together with a <<build-update, change update package>>.

Documentation changes are recommended to be done at the end of <<workflow, branch development>>,
using <<change-file, change file>> as an intermediate notes. The samples of documentation's format may be found <<samples.adoc#, here>>.

Due the strict references and snippets checking, it is quite possible to have broken <<test-unit-and-doc, state>> of documentation
even without .adoc files. Something like the following:
[source]
----
2020-05-25 12:17:39,149 INFO DocGenerator [main] Processing: srcx/doc/project.adoc
2020-05-25 12:17:39,844 ERROR Snippet [main] Snippet '../../src/ru/bgcrm/struts/action/MessageAction.java' doesn't start from: 'message.se', line number: 205, content: newProcess.setDescription(message.getSubject());
2020-05-25 12:17:39,855 ERROR Snippet [main] Snippet '../../src/ru/bgcrm/struts/action/MessageAction.java' doesn't end on: ');', line number: 71, content: if (message == null)
2020-05-25 12:17:39,859 ERROR Snippet [main] Snippet '../../src/ru/bgcrm/struts/action/MessageAction.java' doesn't start from: 'pu', line number: 241, content:
2020-05-25 12:17:39,860 ERROR Snippet [main] Snippet '../../src/ru/bgcrm/struts/action/MessageAction.java' doesn't end on: '}', line number: 253, content:
2020-05-25 12:17:39,911 ERROR Snippet [main] Snippet '../../webapps/WEB-INF/jspf/user/search/search.jsp' doesn't start from: '<div', line number: 1, content: <%@ page contentType="text/html; charset=UTF-8"%>
2020-05-25 12:17:39,911 ERROR Snippet [main] Snippet '../../webapps/WEB-INF/jspf/user/search/search.jsp' doesn't end on: '/div>', line number: 134, content: <%@ include file="/WEB-INF/jspf/shell_title.jsp"%>
2
----

For such cases here is the *fixing algorithm*.
First, find the failing line in `.adoc` file:

image::_res/snippet_fix_1.png[]

After that, using branch comparism, find the new rows and change them in the `.adoc`:

image::_res/snippet_fix_2.png[]

== Architecture
BGERP представляет из себя standalone Java приложение с динамическим Web интерфейсом.
Запуск во время разработки может быть <<ide-run, произведён>> прямо в IDE.

Принципиальная структура обработки запросов изображена ниже.
[ditaa]
----
+----------------+             AJAX
|                |    +----+           +-------------+     +----------+
|      HTML      |    | JS |           |             |     |{s}       |
|                +-=->+    +-----+=+-->+ Java Action +<-=->+ MySQL DB |
|                |    |    |           |             |     |          |
|                |    |    +<----+=+---+             |     +----------+
|                |    |    | CHANGE OK +------+------+
|                |    |    | ANY ERROR        |
|                |    |    |                  :
|       +--------+    |    |                  |
|       |  HTML  |    |    |                  v
|       |        +<-=-+    |           +------+------+
|       |Fragment|    |    +<----+=+---+     JSP     |
|       +--------+    +----+   READ    +-------------+
|                |
+----------------+
----

Этапы обработки:
[arabic]
. Запрос формируется с помощью JS из HTML формы и отправляется в метод класса Java Action.
. На запрос изменения отправляется только подтверждение - JSON документ со статусом OK.
. Любое исключение в процессе работы Action приводит к отправке на клиентскую сторону JSON со статусом ERROR.
. На запрос чтения данных в случае корректной обработки отправляется фрагмент HTML документа, встраиваемый на клиенте в нужное место.
Например, таблица со списком пользователей.

[[tech-stack]]
Стек используемых технологий в порядке убывания важности:
[arabic]
. Java - вся <<action, логика>> реализуется в Java коде, поскольку он предоставляет лучшие параметры по удобству разработки, надёжности и быстродействию;
.. MySQL + JDBC - работа с <<db, данными>>;
. HTML + CSS - язык разметки в браузере и таблицы стилей;
. JSP + JSTL - шаблоны отрисовки HTML страниц, уровень <<jsp, представления>>;
. JS + JQuery - скриптовый язык для динамических возможностей на странице браузера, используется минимально в виде готовых вызовов фреймворка.

IMPORTANT: Избегать смешения слоёв: логики вне Java, представления вне JSP, манипулирования данными вне MySQL.

[[db]]
==== Database
<<kernel/db.adoc#, Структура базы>> документируется в общем <<documentation, процессе>>, одновременно c внесением изменений.
В приложение база создаётся и <<kernel/install.adoc#update, обновляется>> SQL скрипто `build/update/db.sql`.
При <<ide-run, запуске в IDE>> этот скрипт может быть выполнен автоматически при каждом старте.

Дополнительно плагины могут содержать собственные <<plugin-db, скрипты>>, выполняемые в момент их инициализации.

[[cache]]
===== Cache
Кэширование во внутренних Map и List используется для ускорения в сотни раз получения справочных значений при
<<jsp, построении UI>>, либо <<kernel/extension.adoc#jexl-process-context, JEXL скриптах>>.
Map объекты позволяют получать объекты по коду, List - упорядоченный по алфавиту список значений.
Примеры кэшируемых объектов: пользователи, их группы, типы процессов, конфигурации.

IMPORTANT: Рекомендуется всегда когда возможно использовать в первую очередь кэши для получения справочников, избегая лишних запросов к БД.

Редактирование справочников происходит напрямую с БД, после редактирования кэш сбрасывается.
[snippet, from="pu", to="}"]
link:../../src/ru/bgcrm/struts/action/admin/UserAction.java#L92-L98[ru.bgcrm.struts.action.admin.UserAction]

[[mvc]]
=== MVC
The project is using Apache Struts framework in a very own and customized way:
[square]
* requests are sent using <<sample-jsp-ui-ajax, AJAX>> and responses update HTML partially
* from Struts's JSP <<jsp-tag, tags>> <<sample-jsp-ui-restore-form, used>> only *<html:form* with *<html:param* inside
* <<action, action>> methods have different signature as standard
* the <<action-form, form>> object has always the same class

[[action]]
==== Java Action
Action классы определяются в `struts-config.xml` файлах, и привязываются к URL запроса. Имя метода передаётся в HTTP параметре запроса *action*.
Если параметр отсутствует, то вызывается *unspecified* метод, подобный способ нежелателен.

Пример объявления акшена с форвардом:
[snippet, from="<ac", to="on>", remove-leading="		"]
link:../../src/ru/bgerp/plugin/blow/struts-config.xml#L4-L8[src/ru/bgerp/plugin/blow/struts-config.xml]

Акшены должны расширять класс javadoc:ru.bgcrm.struts.action.BaseAction[], методы возвращать результат через вызов *data* либо *status*.
Первый метод обрабатывается JSP страницей-форвардом и высылает HTML на клиент. Второй - предназначен для выполнения изменений и возвращает только JSON формат с результатом выполнения.

[[action-form]]
====== Form Object
В каждый вызов акшена передаётся *супер объект form* javadoc:ru.bgcrm.struts.form.DynActionForm[], содержащий контекст выполнения:
[square]
* пользователь;
* параметры запроса, вспомогательные методы для их разбора.

CAUTION: Не использовать устаревший формат акшенов с параметрами HttpClientRequest и HttpClientResponse, они есть в form.

Фрагмент читающего акшен метода с форвардом.
[snippet, from="pu", to="}", remove-leading="    "]
link:../../src/ru/bgerp/plugin/blow/struts/action/BoardAction.java#L38-L58[ru.bgerp.plugin.blow.struts.action.BoardAction]

Результат перенаправляется на JSP страницу:
link:../../webapps/WEB-INF/jspf/user/plugin/blow/board/show.jsp[webapps/WEB-INF/jspf/user/plugin/blow/board/show.jsp].

В этом же *form* следует передавать данные для отрисовки JSP, за исключением различных вспомогательных справочников.
Для этого используется поле *response* формы.
При *responseType=json*, всё отправленное в response сериализуется в JSON, именно поэтому справочники следует помещать в HttpResponse.

[snippet, from="pu", to="}", remove-leading="    "]
link:../../src/ru/bgcrm/plugin/dispatch/struts/action/DispatchAction.java#L46-L52[ru.bgcrm.plugin.dispatch.struts.action.DispatchAction]

[[action-name]]
===== Именование
Классы акшенов <<plugin, плагинов>> должны располагаться в пакете `PLUGIN_PACKAGE.action`, имя класса оканчиваться на *Action*.
Ранее акшены располагались в пакетах `struts.action`, такой подход является устаревшим.

Акшены <<kernel/interface.adoc#, интерфейса>> *user* разделяются на /user и /admin.
Деление это в будущем возможно будет использовано для выделения административных вызовов.

Интерфейсы *usermob* и *open* содержат свои акшены, в имени пакетов и URL которых должно располагаться *usermob* и *open* соответственно.
Пример такого акшена link:../../src/org/bgerp/action/usermob/ProcessAction.java[org.bgerp.action.usermob.ProcessAction]

Рекомендуемая схема именования методов:
[arabic]
. опционально имя обрабатываемого объекта, если класс работает с несколькими объектами;
. глагол, определяющий операцию, для CRUD это: *list*, *get*, *update*, *delete*;

Примеры имён методов из javadoc:ru.bgcrm.struts.action.admin.UserAction[]:
[square]
* permsetList;
* permsetGet;
* permsetUpdate.

В javadoc:ru.bgcrm.struts.action.admin.AppAction[]:
[suare]
* status - статус приложения;
* update - установка обновления;
* userLoggedList - список авторизовавшихся пользователей.

Форвард рекомендуется называть так же как метод:
[snippet, from="<action path=\"/admin", to="</action>", remove-leading="		"]
link:../../webapps/WEB-INF/struts-config.xml#L55-L58[webapps/WEB-INF/struts-config.xml]

[[action-permission]]
===== Проверка прав
Все методы акшенов должны быть объявлены в файле link:../../src/ru/bgcrm/model/user/action.xml[ru/bgcrm/model/user/action.xml] для ядра либо для <<plugin, плагина>>.
Пример объявления акшенов плагина Blow: link:../../src/ru/bgerp/plugin/blow/action.xml[ru/bgerp/plugin/blow/action.xml]
Действия из данных файлов образуют дерево, использующееся для <<kernel/setup.adoc#user, разграничения доступа>>.

Каждое действия идентифицируется классом и методом, разделёнными точкой с запятой.
Через точку с запятой перед основным идентификатором можно указать дополнительные, например, при переименовании классов либо методов.
Это позволяет обеспечить обратную совместимость ранее записанных в БД привелегий. При следующем сохранении набора прав будет использован новый идентификатор.

[snippet, from="<item ti", to="с\"/>", remove-leading="		"]
link:../../src/ru/bgcrm/model/user/action.xml#L145-L146[ru/bgcrm/model/user/action.xml]

Вспомогательные действия, которые должны быть постоянно разрешены помечаются атрибутом *allowAll="1"*.

[[exception]]
===== Обработка ошибок
Исключение прерывает выполнение акшена, прерывает тразакцию в <<db, БД>>, ответ отправляется всегда в JSON формате.
Обработка исключений производится централизованно в javadoc:ru.bgcrm.struts.action.BaseAction[], методы DAO либо обработчики скриптов должны просто выбрасывать их все наружу.
Соответственно в декларациях методов акшенов и DAO должно значиться *throws java.lang.Exception*.

Класс javadoc:ru.bgcrm.model.BGException[] используется для исключений, генерируемых самой системой, в чистом виде нужен весьма редко.

Его наследник класс javadoc:ru.bgcrm.model.BGMessageException[] используется для отправки <<l10n, локализованного>>
уведомления пользователю, без записи сообщения в лог. Пример:

[snippet, from="for (", to=");", remove-leading="            "]
link:../../src/ru/bgcrm/event/listener/ProcessClosingListener.java#L39-L41[ru.bgcrm.event.listener.ProcessClosingListener]

[[action-db]]
===== Работа с БД
Работа с базой данных выполняется через отдельные Java DAO (Data Access Objects) классы. Непосредственно в акшенах используются уже они.
Обработка запросов <<action, акшенами>> производится транзакционно: транзакция начинается перед вызовом метода, далее подверждается (COMMIT) при возврате
результатов без ошибок либо отменяется (ROLLBACK) при выбросе исключения.

Соединение с базой передаётся в параметрах *con* акшен методов. Также есть варианты методов с параметром *conSet* (javadoc:ru.bgcrm.util.sql.ConnectionSet[]), выдающим соединения по отдельному вызову.
Данный способ подходит для методов не требующих соединения с БД, либо же наоборот, требующих несколько видов соединений: реплики или мусорной для некритичных данных БД (пока не поддержана).

Имена таблиц указываются в константах, для повышения связанности кода, например: javadoc:ru.bgcrm.dao.Tables[]
Если таблица используется только в единственном DAO классе, то константу с её именем делать приватной: javadoc:ru.bgcrm.plugin.fulltext.dao.SearchDAO[]

Для сборки запросов рекомендуется использование класса link:https://docs.oracle.com/en/java/javase/11/docs/api/java.sql/java/sql/PreparedStatement.html[java.sql.PreparedStatement]
либо более удобной его обёрткой ru.bgcrm.util.sql.PreparedDelay[]. Второй класс удобен возможностью склеивать как запросы, так и параметры и не указывать
номер позиции устанавливаемых параметров.

[[jsp]]
==== JSP View
HTML страницы отрисовываются на серверной стороне <<kernel/extension.adoc#jsp, JSP шаблонами>>, получая даннные от Action.
UI реализован из унифицированных компонентов таким образом, что в большинстве случаев что не требуется устанавливать стили,
писать дополнительные JS обработчики. Примеры <<sample-jsp-ui, кода JSP UI>>.

[[jsp-request-params]]
===== SetRequestParamsFilter
The filter is executing after action and sets in request object Java objects, those methods may be called.
The following objects prefixes are available:
[[square]]
* *u.* javadoc:ru.bgcrm.util.Utils[]
* *tu.* javadoc:ru.bgcrm.util.TimeUtils[]
// duplicated in kernel/extension.adoc
* *su* link:https://commons.apache.org/proper/commons-lang/javadocs/api-2.5/org/apache/commons/lang/StringUtils.html[org.apache.commons.lang.StringUtils]
* *сu* link:https://commons.apache.org/proper/commons-collections/javadocs/api-3.2.2/org/apache/commons/collections/CollectionUtils.html[org.apache.commons.collections.CollectionUtils]

As an example see <<sample-date-format, date and time format>>.

Beside of the mentioned static functions, the filter sets also <<cache, caches>>.
All the request parameters are set in class link:../../src/ru/bgcrm/servlet/filter/SetRequestParamsFilter.java[ru.bgcrm.servlet.filter.SetRequestParamsFilter]

[[jsp-function]]
===== Functions
JSP functions are defined in the directory `webapps/WEB-INF/tld`.
Same as for tags IDEs support autocomplition for them.

IMPORTANT: Most of the functions there are deprecated because of possibility to <<jsp-request-params, call>> Java analogs.

Using semicolumn-separated JSP functions makes sence only for JSP specific things, like in the following cases.

[[jsp-function-uiid]]
====== Идентификация элементов
В HTML DOM все идентификаторы элементов глобальные с использованием атрибутов `class` и `id`. Их довольно сложно отслеживать на предмет
используемости и уникальности, а кроме того приложение обязательно должно быть одностраничным, что мешает сохранять состояние на скрытых элементах.
Для обхода этого неудобства в проекте используется привязка JS обработчиков через HTML атрибуты onClick и т.п., с применением конекстной переменной `this`.
Либо генерируется уникальный идентификатор с помощью JSP функции `u:uiid()`, который также подставляется в сгенерированный вызов JS.

[[jsp-tag]]
===== Tags
Компоненты выполнены как JSP теги, объявлены в каталоге `webapps/WEB-INF/tags`.
<<eclipse, IDE Eclipse>> поддерживает автодополнение при их использовании.

image::_res/ide_jsp_tag.png[width='600px']

Обзор использования тегов с элементами управления пользователя вы можете посмотреть в файле link:../../webapps/test.jsp[webapps/test.jsp],
для выполнения шаблона наберите в браузере http://<host>:<port>/test.jsp, для Demo системы: http://demo.bgerp.ru/test.jsp

Пункты меню, устанавливающие соответствие между URL оснастки и Java Action определяются для ядра в файле
link:../../webapps/WEB-INF/jspf/user/menu.jsp[webapps/WEB-INF/jspf/user/menu.jsp], для плагинов - через точку <<plugin-xml-ui-menu, расширения>>.

[[jsp-tag-u-sc]]
====== u:sc
JSP страница хранит все переменные глобально. В сочетании с инклудами и большими шаблонами это может создавать неудобства.
Для обхода проблемы используется тег восстановления контекста `<u:sc>`, все переменные созданные внутри него сбрасываются при выходе.

[[jsp-tag-p-check]]
====== p:check
The tag enabling code inside only when mentioned <<action, action>> is <<action-permission, allowed>> for the current user.
[snippet, from="<p:ch", to=">"]
link:../../webapps/WEB-INF/jspf/user/plugin/blow/board/show.jsp#L11-L14[webapps/WEB-INF/jspf/user/plugin/blow/board/show.jsp]

[[jsp-tags-top-line]]
====== shell:title and shell:state
Set the left area and the right areas of <<kernel/interface.adoc#user-top-line, top line>> in user interface.
<<l10n, Localization>> is supported using *ltext* attribute. Tag shell:state may create a documentation help link.
[snippet, from="<shell:t", to=">"]
link:../../webapps/WEB-INF/jspf/admin/config/list.jsp#L34-L35[webapps/WEB-INF/jspf/admin/config/list.jsp]

[[js]]
==== Java Script
JS используется для обеспечения динамического поведения на странице клиента.
Скрипты и библиотеки к ним располагаются по следующим <<js-lib, путям>>, <<plugin, плагины>> могут обладать собственными скриптами.

В некоторых местах код JS генерируется на стороне сервера в JSP шаблонах.
Данный способ не очень предпочтителен, поскольку сложен для отладки в браузере.

Функции системы разбиты по объектам, выстроенных в иерархию от корневого объекта *+++$$+++*.
Например: link:../../webapps/js/kernel.ajax.js[+++$$+++.ajax], link:../../webapps/js/kernel.ui.js[$$.ui]
Обычная схема привязки JS кода к HTML: установка обработчиков событий с вызовом функций, <<sample-jsp-ui, пример AJAX>>.

Устаревшие JS функции помечаются следующим образом:
[snippet, from="fun", to="}"]
link:../../webapps/js/kernel.ajax.js#L352-L357[webapps/js/kernel.ajax.js]

При их вызове в console бразузера выводится сообщение: "Deprecated", при клике по которому можно найти устаревший вызов.
Использование подобных функций не допускается в новом коде и должно уменьшаться в существующем.

[[plugin]]
=== Плагины
Всякая логически обособленная функциональность должна быть вынесена в плагин.
Особенностью плагинов является их изолированность. Каждый плагин работает с ядром,
ядро не знает особенностей конкретного плагина, плагины не знают друг о друге.
Под *знанием* тут подразумевается полагание на конкретное API, вызовы.

[[plugin-class]]
==== Java класс плагина
Плагины находятся программой при старте по обязательному Java классу, расширяющему javadoc:ru.bgcrm.plugin.Plugin[]
Пример класса: link:../../src/ru/bgerp/plugin/blow/Plugin.java[ru.bgerp.plugin.blow.Plugin]

Каждый плагин должен уникальным *Java package*, содержащим данный класс.
Далее пакет плагина будет обозначаться как *PLUGIN_PACKAGE*.

В методе инициализации класса плагина могут определяться слушатели событий:
[snippet, from="Eve", to="ss);", remove-leading="        "]
link:../../src/ru/bgcrm/plugin/slack/Plugin.java#L21-L23[ru.bgcrm.plugin.slack.Plugin]

В данном случае в <<kernel/extension.adoc#jexl, JEXL>> контекст помещается обработчик функций.

Каждый плагин должен обладать уникальным строковым *идентификатором*, удовлетворяющим следующим условиям:
[square]
* одно уникальное для данного плагина английское слово без перемены регистра и спецсимволов;
* <<db, таблицы БД>> плагина, если они есть, должны начинаться с идентификатора;
* <<action, actions>> плагина, если они есть, должны начинаться с /user/plugin/идентификатор.

[[plugin-db]]
Если плагин использует <<db, БД>>, то в его пакете может находиться скрипт, создающий и изменяющий таблицы.
Скрипт с именем `db.sql` вызывается при стандартной процедуре инициализации.

Пример скрипта для плагина FullText.
[snippet]
link:../../src/ru/bgcrm/plugin/fulltext/db.sql[src/ru/bgcrm/plugin/fulltext/db.sql]

[[plugin-xml]]
==== XML декларация
Необязательный файл `plugin.xml`, располагающийся в *PLUGIN_PACKAGE*

В файле определяются точки расширения:
[square]
* JSP шаблоны;
* JS файлы.

[[plugin-xml-ui-menu]]
===== Пункты меню
Объявление точки расширения в XML декларации:
[snippet, from="<en", to=">", remove-leading="	"]
link:../../src/ru/bgerp/plugin/blow/plugin.xml#L4-L4[blow/plugin.xml]

Добавление пункта с помощью тега JSP: link:../../webapps/WEB-INF/jspf/user/plugin/blow/menu_items.jsp[webapps/WEB-INF/jspf/user/plugin/blow/menu_items.jsp]

[[plugin-xml-js]]
===== JavaScript
Объявление точки расширения в XML декларации:
[snippet, from="<en", to=">", remove-leading="	"]
link:../../src/ru/bgerp/plugin/blow/plugin.xml#L5-L5[blow/plugin.xml]

Файл со скриптом: link:../../webapps/js/pl.blow.js[webapps/js/pl.blow.js]

[[plugin-action]]
==== Actions
<<action, Акшены>> плагина, если требуется, должны быть определены в *PLUGIN_PACKAGE.action* каталоге.
Файлы `struts-config.xml` и `action.xml` должны находится в *PLUGIN_PACKAGE*.

JSP шаблоны - `webapps/WEB-INF/jspf/user|open|usermob/plugin/идентификатор`.

[[plugin-l10n]]
==== Локализация
Файл <<l10n, локализации>> плагина `i10n.xml` должен находиться в *PLUGIN_PACKAGE*.
Он используется только для локализаций акшенов и JSP шаблонов в них.

[[custom-level]]
=== Кастомизация
Одним из изначальных приоритетов системы была расширяемость и гибкость.
Поэтому стандартный функционал может быть <<kernel/extension.adoc#tech-choice, расширен>> несколькими способами.

Следует однако понимать, что наиболее эффективный путь разработки и долгосрочной поддержки функциональности
- реализация в виде штатного плагина либо части ядра, с вынесением необходимого минимума параметров в конфигурацию.
JEXL скрипты либо динамический код могут быть использованы для быстрого прототипирования,
либо реализации *исключительно специфичной для данной инсталляции* логики.

Практика показывает, что из всего набора кастомизированных попыток постепенно
выявляются удачные решения, которые подходят значительному числу пользователей.
Такие необходимо переносить в основной код, делая частью системы и совместно развивая её дальше.

Следующая диаграмма визуально отображает данную динамику трансформации совокупной массы программного кода разных типов.
Объём кода учитывается для всех клиентов, бОльший объём из разрозненных *решений* преобразуется в меньший объём более универсального кода единого *продукта*.

[ditaa]
----
+--------------+   +--------------+  +-----------------------+
|              |   |              |  |                       |
|              |   |              |  |                       |
|  Custom JSP  |   |  Dyn Code    |  |      Configuration    |
|              |   |              |  |                       |
|              |   |              |  |         +JEXL         |
|              |   |              |  |                       |
+------+-------+   +-----------+--+  +-+----------+----------+
       |                       |       |          |
       v                       v       v          v
+------+-------+           +---+-------+-+ +------+------+
| Standard JSP |           |  Java Code  | |Configuration|
+--------------+           +-------------+ +-------------+
----

[[l10n]]
=== Localization
Все сообщения в логах не локализуются и выводятся на английском языке.

Локализуется интерфейс и сообщения, адресованные пользователю системы.
Язык системы задаётся глобально в <<kernel/setup.adoc#config, конфигурации>>.

[[l10n-files]]
==== Files
XML файл локализации `l10n.xml` для ядра располагается в `src/ru/bgerp/l10n`, для <<plugin-l10n, плагинов>> - в их пакетах .
Новые локализирующие фразы должны добавляться в начало списка в файле.

NOTE: Для отключения в момент разработки кэширования локализаций установите в конфигурации *localization.cache=0*

Ключом локализирующей фразы выступает первая запись на любом языке, например русском:
[source, xml]
----
<p><ru>Требуется повторная авторизация</ru><en>Re-authorization is required</en></p>
----

Возможно использование коротких сокращённых ключей, представляя их в виде записей на особом системном языке, например:
[source, xml]
----
<p><sys>reauth.message</sys><ru>Требуется повторная авторизация</ru><en>Re-authorization is required</en></p>
----

Для изменения надписей на кнопках в интерфейсе, следует применять добавление отдельной локализации (изменять русскую локализацию не получится, так как она испольузется как ключ), например меняем кнопку в мастере создания, через язык my:
[source, xml]
----
<p><ru>Завершить</ru><en>Finish</en><my>Создать заявку</my></p>
----

[[l10n-code]]
==== Code
Локализация может выполняться в JSP шаблонах и Java акшенах. В JS коде локализация доступна, только если он генерируется JSP.

В коде JSP шаблона вызов локализации из примера выше выглядит следующим образом:
[source, jsp]
----
$('#loginForm').dialog({
	modal: true,
	draggable: false,
	resizable: false,
	title: "${l.l('Требуется повторная авторизация')}",
	position: { my: "center top", at: "center top+100px", of: window }
});
----

При выполнении <<action, акшена>> в объект *l* передаётся локализационный контекст, содержащий фразы для ядра и вызываемого плагина.

[snippet, from="message.se", to="());", remove-leading="        "]
link:../../src/ru/bgcrm/struts/action/MessageAction.java#L227-L227[ru.bgcrm.struts.action.MessageAction]

Localized key string may contain placeholders for some values, marked as *%s*.
Such case may be seen for <<exception, BGMessageException sample>>.

==== Development
All the new code has to be written using localized strings.
For legacy code recommended during other changes replace static strings to localized.

For figuring out missing keys add in <<log4j, logging configuration>>:
[source]
----
log4j.logger.ru.bgerp.l10n.Localizer=DEBUG, stdout
log4j.additivity.ru.bgerp.l10n.Localizer=false
----

== Именование
=== Переменные конфигураций, функции JS, HTTP StyleId
[square]
* Все переменные конфигурации от плагинов начинать как <plugin>:
* Все функции JS плагинов начинать с префикса <plugin>-
В других местах тире запретить в названии функции.
* Все идентификаторы (style id) DOM элементов для плагинов начинать как <plugin>-
В других местах тире запретить в названиях  идентификаторов.

=== База данных
1) Таблицы и поля в них именовать с нижним подчёркиванием.
process_id
param_id

=== Переменные Java, параметры HTTP запросов, переменные в JSP
В camelCase нотации:
processId
paramId

=== Дата - поле сущности
Если в поле только дата, то:
createDate - Java - тип java.util.Date
create_date - БД - тип date

Если в поле дата + время, то:
createTime - Java - тип java.util.Date
create_dt - БД - тип datetime

=== Дата - период сущности
В бинах дату периода хранить с типом java.util.Date с именем:
dateFrom
dateTo

Соответственно методы получения и установки:
setDateFrom
setDateTo
getDateFrom
getDateTo

CAUTION: Не использовать для хранения в бинах Calendar.
Если нужно конверить в календарь или из календаря - использовать TimeUtils.

Если нужно хранить время, то делаем:
timeFrom
timeTo

Также тип java.util.Date.

Calendar использовать во всяких калькуляторах/тарификаторах, когда реально нужно постоянно двигать дату.

В базе использовать поля from_date и to_date, тип date.

from_dt, to_dt - тип datetime.

Неограниченные даты - NULL.

[[samples]]
== Code samples
Так как система очень быстро меняется, то здесь собираются примеры актуального кода, рекомендуемого к использованию.
Сниппеты извлекаются непосредственно из исходных файлов проекта, поэтому всегда достоверны.
При необходимости воспользуйтесь IDE для поиска классов или файлов.

=== Сохранение последних параметров запроса пользователя
Например, фильтров интерфейса. Используется метод *restoreRequestParams* в: javadoc:ru.bgcrm.struts.action.BaseAction[]

Сохранение значения:
[snippet, from="resto", to=");", remove-leading=    "]
link:../../src/ru/bgcrm/struts/action/MessageAction.java#L88-L88[ru.bgcrm.struts.action.MessageAction]

Восстановление:
[snippet, from="pu", to="}", remove-leading="    "]
link:../../src/ru/bgcrm/struts/action/MessageAction.java#L264-L276[ru.bgcrm.struts.action.MessageAction]

Сохранение плюс восстановление сразу:
[snippet, from="//", to=");", remove-leading="    "]
link:../../src/ru/bgcrm/struts/action/ProcessLinkAction.java#L52-L56[ru.bgcrm.struts.action.ProcessLinkAction]

=== Отображение на вкладке количества элементов
Например, количества связанных процессов. Сохраняется при первом вызове.
Используется класс javadoc:ru.bgcrm.model.IfaceState[]

Обновление значения:
[snippet, from="// п", to="}", remove-leading="        "]
link:../../src/ru/bgcrm/struts/action/ProcessLinkAction.java#L220-L227[ru.bgcrm.struts.action.ProcessLinkAction]

Show in JSP:
[snippet, from="<c:if", to="if>", remove-leading="						"]
link:../../webapps/WEB-INF/jspf/user/process/process/process_editor.jsp#L81-L95[webapps/WEB-INF/jspf/user/process/process/process_editor.jsp]

[[sample-date-format]]
=== Date and time format
При форматировании дат и времени в Java либо JSP для независимости от текущей локали и унификации используются форматы вида:
[square]
* *ymd* - год, месяц, день;
* *ymdh* - год, месяц, день, час;
* *ymdhm* - год, месяц, день, час, минута;
* *ymdhms* - год, месяц, день, час, минута, секунда.

В Java коде для форматирования дат используется класс javadoc:ru.bgcrm.util.TimeUtils[],
в нём же есть константы с форматами.

The same functions may be used in <<jsp, JSP>> using `tu` prefix:
[snippet, from="<input type=", to="d}\"/>", remove-leading="				"]
link:../../webapps/WEB-INF/jspf/user/parameter/edit.jsp#L158-L158[webapps/WEB-INF/jspf/user/parameter/edit.jsp]

=== Бины конфигурации
Для ускорения парсинга и валидации используются Java объекты с классом, наследующим javadoc:ru.bgcrm.util.Config[].
Например: link:../../src/ru/bgcrm/model/config/IsolationConfig.java[ru.bgcrm.model.config.IsolationConfig].
Данная конфигурация поддерживает конструктор с флагом валидации, что позволяет проверять синтаксис при сохранении.

Бины конфигурации могут быть получены и в JSP:
[snippet, from="<c:", to="/>"]
link:../../webapps/WEB-INF/jspf/user/plugin/task/task_list.jsp#L4-L4[webapps/WEB-INF/jspf/user/plugin/task/task_list.jsp]

[[sample-logging]]
=== Logging
==== Java
Используется класс логгер javadoc:ru.bgerp.util.Log[], базирующийся на фрейморке <<kernel/extension.adoc#log4j, Log4j>>.
При запуске в IDE конфигурационный файл из дистрибутива link:../../build/bgerp/files/log4j.properties[build/bgerp/files/log4j.properties]
может быть скопирован в корень проекта и изменён требуемым образом.

Для логирования в <<action, actions>> использовать *protected* переменную `log`.

В Java классах создавать *static final* переменную класса:
[snippet, from="pub", to=");"]
link:../../src/ru/bgcrm/worker/MessageExchange.java#L16-L19[ru.bgcrm.worker.MessageExchange]

Вывод сообщения при исключении:
[snippet, from="try", to="}", remove-leading="					"]
link:../../src/ru/bgcrm/worker/MessageExchange.java#L60-L64[ru.bgcrm.worker.MessageExchange]

==== JS
Вывод отладки вместо console.log:
[snippet, from="con", to="}"]
link:../../webapps/js/kernel.shell.js#L5-L12[webapps/js/kernel.shell.js]

Enabling debug:
[snippet, from="$$.", to="0,"]
link:../../webapps/js/kernel.js#L18-L22[webapps/js/kernel.js]

=== Постраничный вывод
Вывод результатов в JSP и отображение формы:
[snippet, from="<c:", to="rm>", remove-leading="		"]
link:../../webapps/WEB-INF/jspf/user/process/process/link_process_list.jsp#L75-L83[webapps/WEB-INF/jspf/user/process/process/link_process_list.jsp]

Java action:
[snippet, from="//", to="open);", remove-leading="        "]
link:../../src/ru/bgcrm/struts/action/ProcessLinkAction.java#L211-L213[ru.bgcrm.struts.action.ProcessLinkAction]

[[sample-jsp-ui]]
=== JSP UI
Простой справочник с промотчиком страниц, вызов редактора AJAX: link:../../webapps/WEB-INF/jspf/admin/process/status/list.jsp[webapps/WEB-INF/jspf/admin/process/status/list.jsp]

[[sample-jsp-ui-ajax]]
Отправка AJAX для сохранения, выхода, либо восстановления данных в <<kernel/process/index.adoc#type, редакторе свойств типа процесса>>:
[snippet, from="<div", to="/div>"]
link:../../webapps/WEB-INF/jspf/admin/process/type/properties.jsp#L191-L196[webapps/WEB-INF/jspf/admin/process/type/properties.jsp]

Рекурсивный инклуд:
[snippet, from="<c:", to="if>", remove-leading="					"]
link:../../webapps/WEB-INF/jspf/admin/user/check_tree_item.jsp#L48-L50[webapps/WEB-INF/jspf/admin/user/check_tree_item.jsp]

Инклуд результата выполнения акшена:
[snippet, from="<c:", to="/>", remove-leading="			"]
link:../../webapps/WEB-INF/jspf/admin/user/user/update.jsp#L161-L166[webapps/WEB-INF/jspf/admin/user/user/update.jsp]

Flex layout, использование констант из Java классов, кнопка вывода рядом с полем:
[snippet, from="<div", to="/div>", remove-leading="				"]
link:../../webapps/WEB-INF/jspf/user/search/search.jsp#L77-L96[webapps/WEB-INF/jspf/user/search/search.jsp]

Обновление оснастки при повторном переходе в неё:
[snippet, from="<script", to="/script>"]
link:../../webapps/WEB-INF/jspf/user/log/log.jsp#L22-L28[webapps/WEB-INF/jspf/user/log/log.jsp]

Отправка AJAX запроса, блокировка кнопки при долгом выполнении действия:
[snippet, from="<bu", to="on>"]
link:../../webapps/WEB-INF/jspf/admin/dynamic/dynamic.jsp#L22-L30[webapps/WEB-INF/jspf/admin/dynamic/dynamic.jsp]

[[sample-jsp-ui-restore-form]]
Restore form parameter values:
[snippet, from="<ht", to="/>"]
link:../../webapps/WEB-INF/jspf/admin/directory/parameter/group/update.jsp#L8-L10[webapps/WEB-INF/jspf/admin/directory/parameter/group/update.jsp]

[[build]]
== Build and publish
Проект сконфигурирован в формате Gradle, конфигурационный файл link:../../build.gradle[build.gradle].
For build and publish except Java is required <<env-console, console enviroment>> with available *ant*, *ssh* and *rsync* packages.

NOTE: Здесь и далее команды приведены в расчёте на WSL окружение, в *NIX системах префикс `bash -c` не требуется.

[[build-doc]]
=== Документация
[source]
----
bash -c "./gradlew clean buildDoc"
----
Собранные HTML файлы доступны в каталоге *target/doc*. Они автоматически проверяются на корректность внутренних ссылок.

[[build-update]]
=== Change update
Build and publish on https://bgerp.org/update update package with a <<workflow, change>>.

[IMPORTANT]
====
Public SSH key or the developer might be added for *bgerp-cdn@pzdc.de*.
Before you publish a change update, make sure that `ssh bgerp-cdn@pzdc.de` sessions work for you.
====

Clean before publish:
[source, bash]
----
bash -c "./gradlew clean buildClean "
----

If there are some <<documentation, documentation>> or <<java-lib, Java libraries>> changes:
[source, bash]
----
bash -c "./gradlew buildUpdateLib buildDoc"
----

Or only application changes:
[source, bash]
----
bash -c "./gradlew buildUpdate"
----

For publish operation make the command:
[source, bash]
----
bash -c "./gradlew publishUpdate"
----

Of course, all the Gradle tasks might be started together, so the typical case is:
[source, bash]
----
bash -c "./gradlew clean buildClean buildUpdate buildDoc publishUpdate"
----

All the updates packages are copies to Web directory: `https://bgerp.org/update/PROCESS_ID`
The <<change-file, change file>> has also copied, and all documentation links there starting from `https://bgerp.org/doc`
are automatically replaced to the `https://bgerp.org/update/PROCESS_ID/doc`.

Пользователи имеют возможность <<kernel/install.adoc#installer, установить>> пакет с помощью команды *install*,
сообщить о выявленных недочётах и откатиться на предыдущую версию командой *update* в случае невозможности работать с ними далее.
Возможна многократная публикация до выявления всех недочётов, после чего именение <<workflow, переносится>>
в основную ветку и <<build-erp, публикуется>> очередное обновление.

[[build-erp]]
=== Release
CAUTION: Check <<unit-test, Unit tests>> running.

[IMPORTANT]
====
Public SSH key or the developer might be added for *bgerp-cdn@pzdc.de* and *www@bgerp.org*.
Before you publish a change update, make sure that `ssh bgerp-cdn@pzdc.de` and `ssh www@bgerp.org` sessions work for you.
====

Сборка производится с *master* ветки и может включать несколько изменений, <<workflow, перенесённых>> на неё.

IMPORTANT: Для каждого переноса делать отдельный GIT push, для корректной <<publish-source, публикации>> в открытом репозитарии.

В зависимости от наличия в обновлении <<java-lib, сторонних библиотек>> выполнить команды:
[source, bash]
----
bash -c "./gradlew buildClean buildUpdate"
----
либо:
[source, bash]
----
bash -c "./gradlew buildClean buildUpdateLib buildUpdate"
----

Далее:
[source, bash]
----
bash -c "./gradlew patchChanges rss publishBuild publishCommit"
----

Check the release commit and make:
[source, bash]
----
git push
----

Merge the latest state of the master on <<documentation, documentation>> branch.

[[build-docker]]
==== Docker Image
[source]
----
docker login --username bgerp
----
Input access token.

Go in directory `build/docker`
[source]
----
bash files.sh &&
docker build . -t bgerp/bgerp &&
docker push bgerp/bgerp
----

[[unit-test]]
=== Unit тесты
Используется фреймворк JUnit, каталог `srcx/test`.
Проверка отдельных алгоритмов, тесты не зависят друг от друга, не работают с БД.

Запуск локально командой:
[source, bash]
----
bash -c "./gradlew clean test"
----

[[integration-test]]
=== Интеграционный тест
Используется фреймворк TestNG, каталог `srcx/itest`.

Интеграционный тест производит сборку, установку и запуск приложения с реальной БД.
Далее в браузере эмулируется различные действия пользователя с проверкой результата.
Тесты образуют граф зависимостей, определяющий порядок и параллельность выполнения.
После успешного прохождения тестов дамп заполненной БД <<test-integration, выгружается>> для http://demo.bgerp.ru

Файл для установки должен быть собран предварительно командой.
[source, bash]
----
bash -c "./gradlew buildErp"
----

`sudo` необходим для установки в стандартный */opt* каталог.

WARNING: Тест пересоздаст базу с именем *bgerp* и переустановит сервер в */opt/BGERP*

[source, bash]
----
sudo GRADLE_OPTS=-Xmx1000m ./gradlew -Ptest.single='ru.bgerp.itest.RunServerTest' -Pdb.host=DB_HOST -Pdb.user=ROOT_USER -Pdb.pswd=ROOT_PSWD integrationTest
----
Параметры DB_HOST, ROOT_USER, ROOT_PSWD - для доступа к MySQL серверу, где будет создана тестовая БД.

==== Selenium e-to-e тест
Может выполнять впоследствия действия на запущенном сервере.
Необходима установка *chromedriver* и указание его в пути.

[source, bash]
----
GRADLE_OPTS=-Xmx1000m ./gradlew -Ptest.single='ru.bgerp.itest.SeleniumTest' -Pwebdriver.chrome.driver=/usr/lib/chromium-browser/chromedriver integrationTest
----

[[gitlab-ci]]
=== GitLab CI
В файле link:../../.gitlab-ci.yml[.gitlab-ci.yml] настроен автоматический запуск задач на каждый коммит в GIT.
Различные задачи выполняются в разных ветках <<workflow, Workflow>>.
Ниже описание CI задач.

[[test-unit-and-doc]]
==== test-unit-and-doc
Запускает <<unit-test, Unit тесты>>, <<build-doc, сборку и проверку документации>>.

[[test-integration]]
==== test-integration
Запускает <<integration-test, интеграционный тест>>.

[[publish-doc]]
==== publish-doc
Запускает <<build-doc, сборку и проверку документации>>, при отсутствии ошибок - публикует её на http://bgerp.ru/doc/manual.

[[publish-source]]
==== publish-source
Публикует актуальные исходные коды из `master` в открытый репозитарий https://github.com/pingvin235/bgerp
Данный способ выбран для уменьшения размера открытого репозитария и сокрытия удалённых ранее файлов из истории.
